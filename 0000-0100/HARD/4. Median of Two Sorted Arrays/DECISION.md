<p>
Подойдем к решению данной задачи с нескольких сторон. Я разберу все возможные временные сложности, после чего приду к верному решению.

Начнем с самого неэффективного решения, где временная сложность будет составлять O((m + n) log(m + n)).
</p>
<h1>Способ 1: Сортировка и поиск медианы</h1>

<h2>Объяснение:</h2>

<h3>Объединение массивов:</h3>
<p>
- Создается новый список arr для хранения всех элементов из массивов nums1 и nums2. 
- В циклах for все элементы из nums1 и nums2 добавляются в список arr.

<h3>Сортировка:</h3>
Список arr сортируется с использованием метода sort, который применяет естественный порядок сравнения (Integer::compareTo).

<h3>Поиск медианы:</h3>
- После сортировки проверяется размер списка arr. 
- Если размер четный, медиана вычисляется как среднее двух центральных элементов: (arr.get(arr.size() / 2) + arr.get(arr.size() / 2 - 1)) / 2.0.
- Если размер нечетный, медиана — это центральный элемент: arr.get(arr.size() / 2).

<h3>Временная сложность:</h3>
Временная сложность этой реализации составляет O((m + n) log(m + n)), где m и n — размеры входных массивов.

<h3>Пространственная сложность:</h3>
Пространственная сложность составляет O(m + n) из-за использования дополнительного списка для хранения всех элементов.

<h3>Вывод:</h3>
Эта реализация подходит для небольших массивов, где простота важнее, чем оптимизация по времени или памяти. Однако для больших наборов данных стоит рассмотреть более эффективные подходы. Данная временная сложность не подходит для решения нашей задачи.

Перейдем ко второму методу с временной сложностью O(m + n).
</p>


<h1>Способ 2: Слияние массивов</h1>

<h2>Объяснение:</h2>


<h3>Инициализация:</h3>
<p>
- Мы определяем длины двух входных массивов nums1 и nums2 как l1 и l2.
- Вычисляем общее количество элементов n = l1 + l2.
- Создаем новый массив arr длиной n для хранения объединенного и отсортированного результата.

<h3>Слияние массивов:</h3>
- Используем три индекса: i для nums1, j для nums2 и k для arr.
- В цикле while попеременно добавляем меньший из элементов nums1[i] и nums2[j] в массив arr.
- Если один из массивов полностью обработан (i == l1 или j == l2), оставшиеся элементы другого массива добавляются в arr.

<h3>Поиск медианы:</h3>
- После завершения слияния массива, проверяем общее количество элементов n.
- Если n четное, медиана — это среднее двух центральных элементов arr[n / 2] и arr[n / 2 - 1].
- Если n нечетное, медиана — это центральный элемент arr[n / 2].

<h3>Временная сложность:</h3>
Эта реализация имеет временную сложность O(m + n), где m и n — размеры входных массивов.

<h3>Пространственная сложность:</h3>
Пространственная сложность составляет O(m + n), так как создается новый массив для хранения всех элементов.

<h3>Вывод:</h3>
Эта реализация хорошо подходит для случаев, когда простота важнее, чем строгое ограничение по использованию памяти. Для нашей задачи также не подходит данное решение.

Перейдем к финальному методу с верным решением и временной сложностью O(log(min(m, n))).
</p>

<h1>Способ 3: Бинарный поиск</h1>

<h2>Объяснение:</h2>

<h3>Оптимизация порядка массивов:</h3>
<p>
Сначала проверяется, чтобы nums1 всегда был меньшим массивом. Это обеспечивает, что двоичный поиск выполняется на массиве меньшего размера, минимизируя количество операций.

<h3>Двоичный поиск:</h3>
Проводится двоичный поиск по меньшему массиву nums1 для нахождения правильной позиции разбиения.
mid1 — это текущая позиция разбиения в nums1, а mid2 — соответствующая позиция разбиения в nums2.

<h3>Определение границ:</h3>
left1 и right1 — это элементы слева и справа от разбиения в nums1.
left2 и right2 — это элементы слева и справа от разбиения в nums2.
Если разбиение находится в начале или в конце массива, используются Integer.MIN_VALUE и Integer.MAX_VALUE для обработки краевых случаев.

<h3>Проверка корректности разбиения:</h3>
Если условие left1 <= right2 && left2 <= right1 выполняется, значит, правильное разбиение найдено:
Если общее количество элементов четное, медиана — это среднее из максимума левой части и минимума правой части.
Если нечетное, медиана — это максимум левой части.

<h3>Корректировка разбиения:</h3>
Если left2 > right1, это означает, что mid1 слишком мал, и low увеличивается.
Иначе mid1 слишком велик, и hight уменьшается.

<h3>Временная сложность:</h3>
Временная сложность составляет O(log(min(m, n))), где m и n — размеры входных массивов.
Это связано с использованием двоичного поиска на меньшем массиве.

<h3>Пространственная сложность:</h3>
Пространственная сложность составляет O(1), поскольку не используется дополнительная память для хранения элементов.

<h3>Преимущества:</h3>
<b>Эффективность:</b> Алгоритм чрезвычайно эффективен и подходит для работы с большими массивами.

<b>Отсутствие дополнительной памяти:</b> Не требует хранения дополнительных данных, что делает его экономичным в плане памяти.

<h3>Вывод:</h3>
Эта реализация является одной из наиболее оптимальных для данной задачи и широко используется благодаря своей эффективности.
</p>